```
// WORK IN PROGRESS //
```

## Symp

a programming framework from a parallel reality where symbols won

---

#### Philosophy

What if there is a world where programming has evolved around source code ergonomics rather than user interface machinery?

* In that world, computer displays never evolved beyond the monochrome text mode.
* Instead, the programming theory advanced far beyond the one from this world.
* Source code became a subject of seeking beauty in structures of its appearance.

Symp is a small, strange, and honest framework evolved from using restricted visuals in a favor of rich programming theory.
It carries a thought experiment from a reality in which symbols triumphed over flashing lights.

---

#### The Architecture

There are two kinds of components in Symp: a core and a device.
There can be many devices, all attached to the core, as shown in the diagram:

```
                  · · · · · · · · ·
                  ·               ·
                  ·  d e v i c e  ·
                  ·               ·
                  · · · · · · · · ·
                          ·
                          ·
· · · · · · · ·     · · · · · · ·     · · · · · · · ·
·             ·     ·           ·     ·             ·
· d e v i c e · · · ·  c o r e  · · · · d e v i c e ·
·             ·     ·           ·     ·             ·
· · · · · · · ·     · · · · · · ·     · · · · · · · ·
                          ·
                          ·
                  · · · · · · · · ·
                  ·               ·
                  ·  d e v i c e  ·
                  ·               ·
                  · · · · · · · · ·
```

Devices may be a front-end interface to the outer world, while the back-end core is quietly connecting all of the devices.

Devices may communicate to each other using the core as a mediating environment which performs the intermediate computations.

The core is pure, stateless, and referentially transparent computing unit, while devices may maintain states during their life cycle.

Together, they form an integrated system capable of performing any kind of computation we may require as its users.

---

## Core

the heart of the system

---

#### What can core be used for?

The core is designed for problems where structure matters more than presentation.

It is especially suited for:

* Designing small languages and interpreters
* Encoding knowledge as executable structure
* Building rule-based reasoning systems
* Meta-programming and symbolic transformation
* Learning computation from first principles

The core is not optimized for speed, graphics, or mass-market applications.
It is optimized for clarity, exactness, and inspectability.

---

#### Docs

* Core: what runs [[specifications](docs/core)] [[pseudocode](docs/specs/core.pseudo)]
* Plus: how humans write [[specifications](docs/plus)] [[pseudocode](docs/specs/plus.pseudo)]
* Star: what is allowed to exist [[specifications](docs/star)] [[pseudocode](docs/specs/star.pseudo)]

---

## Devices

the periphery of the system

---

```
// WORK IN PROGRESS //
```

