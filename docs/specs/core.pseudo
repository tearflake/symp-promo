/////////////////////////////////
// Symp Core v0.x (Pseudocode) //
/////////////////////////////////

// program

CoreModuleTree: {
    item: PlusModule,
    children: CoreModuleTree[]
}

CoreModule: CoreDecl[]

CoreDecl: {
    kind: "PARAMS"
} | {
    kind: "FUNCTION",
    result: CoreTerm
}

// expression

CoreTerm: CoreAtom | CoreList

CoreAtom: Identifier | Literal

CoreList: {
    kind: "LIST",
    head: CoreTerm,
    tail: CoreTerm[]
}

Identifier: {
    kind: "IDENTIFIER",
    module: String[],
    label: String,
}

Literal: {
    kind: "LITERAL",
    value: String
}

// interpreter

function reduce(expr: CoreTerm, moduleTree: CoreModuleTree): CoreTerm
    while true
        if expr.kind == "LITERAL"
            return expr
        
        if expr.kind == "IDENTIFIER"
            [ok, module] = getModule(moduleTree, expr)
            if (not ok) or (not expr.label in module)
                return {head: {module: [], label: "ERROR"}, tail: [`Unknown alias or identifier ${expr.label}`]}
            
            return expr // Identifiers are inert unless in head position;
        
        head = reduce(expr.head, moduleTree)
        if head.kind == "IDENTIFIER"
            if head.label == "Args" or head.label == "ERROR" // arg list and error are valid heads
                return expr
            
            if head.label == "IsEq" // test for atom equality
                if expr.tail.length != 2
                    return {head: {module: [], label: "ERROR"}, tail: [`'Eq' requires two parameters`]}
                                    
                cond = (reduce(expr.tail[0], moduleTree) == reduce(expr.tail[1], moduleTree))
                expr = {module: [], label: (cond ? "True" : "False"}
                continue
            
            if head.label == "IsAtom" // test if argument is atom
                if expr.tail.length != 1
                    return {head: {module: [], label: "ERROR"}, tail: [`'IsAtom' requires one parameter`]}
                
                redExpr = reduce(expr.tail[0])
                cond = (redExpr.kind != "LIST")
                expr = {module: [], label: (cond ? "True" : "False"}
                continue
            
            if head.label == "IsEmpty" // test if list is empty
                if expr.tail.length != 1
                    return {head: {module: [], label: "ERROR"}, tail: [`'IsEmpty' requires one parameter`]}
                
                redExpr = reduce(expr.tail[0], moduleTree)
                if redExpr.kind != "LIST"
                    return {head: {module: [], label: "ERROR"}, tail: [`'IsEmpty' requires list as parameter`]}

                cond = (redExpr.tail.length == 0)
                expr = {module: [], label: (cond ? "True" : "False"}
                continue
            
            if head.label == "FAH" // first element after head
                if expr.tail.length != 1
                    return {head: {module: [], label: "ERROR"}, tail: [`'FAH' requires one parameter`]}
                
                redExpr = reduce(expr.tail[0], moduleTree)
                if redExpr.kind != "LIST"
                    return {head: {module: [], label: "ERROR"}, tail: [`'FAH' requires list as parameter`]}

                if (redExpr.tail.length == 0)
                    return {head: {module: [], label: "ERROR"}, tail: [`'FAH' on empty list`]}
                
                expr = redExpr.tail[0]
                continue
            
            if head.label == "RAH" // rest of elements after head
                if expr.tail.length != 1
                    return {head: {module: [], label: "ERROR"}, tail: [`'RAH' requires one parameter`]}
                
                redExpr = reduce(expr.tail[0], moduleTree)
                if redExpr.kind != "LIST"
                    return {head: {module: [], label: "ERROR"}, tail: [`'RAH' requires list as parameter`]}
                
                if (redExpr.tail.length == 0)
                    return {head: {module: [], label: "ERROR"}, tail: [`'RAH' on empty list`]}
                
                expr = {head: redExpr.head, tail: redExpr.tail[1..]}
                continue
            
            if head.label == "IAH" // insert element after head
                if expr.tail.length != 2
                    return {head: {module: [], label: "ERROR"}, tail: [`'IAH' requires two parameters`]}
                
                redExpr = reduce(expr.tail[1], moduleTree)
                if redExpr.kind != "LIST"
                    return {head: {module: [], label: "ERROR"}, tail: [`'IAH' requires list as second parameter`]}

                expr = {head: redExpr.head, tail: [reduce(expr.tail[0], moduleTree), ...redExpr.tail]}
                continue
                
            [ok, module] = getModule(moduleTree, head)
            if ok and (head.label in module)
                if module[head.label].kind == "FUNCTION"
                    expr = substitute(module[head.label].result, {head: head, tail: expr.tail}, moduleTree)
                    continue
                
                return {head: head, tail: expr.tail.map((e) => reduce(e, moduleTree))}
        
            return {head: {module: [], label: "ERROR"}, tail: [`Unknown alias or identifier`]}
            
        return {head: {module: [], label: "ERROR"}, tail: [`Head must reduce to identifier`]}

function getModule(moduleTree: CoreModuleTree, expr: Identifier): [Boolean, CoreModule]
    module = moduleTree
    for mod in expr.module
        if module.children[mod.key] not exists
            return [false, null]
        
        module = module.children[mod.key]
    
    return [true, module.item]

function substitute(expr: CoreTerm, args: CoreList, moduleTree: CoreModuleTree): CoreTerm
    if expr.kind == "LITERAL"
        return expr

    if expr.kind == "IDENTIFIER"
        if expr.label == "Args"
            return {head: {module: [], label: "Args"}, tail: args.tail}
    
        return {module: [...args.head.module, ...expr.module], label: expr.label} // all module paths are relative
    
    return {head: substitute(expr.head, args, moduleTree), tail: expr.tail.map(e => substitute(e, args, moduleTree)}

