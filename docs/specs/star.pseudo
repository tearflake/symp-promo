/*
## 1. High-level architecture

The Symp Star framework is best seen as **three passes**:

1. **validate parameters**
   Build pairs param -> interface.
2. **validate results**
   Walk expressions and ensure every `GET`, application, and composition is admissible.
3. **Erasure / projection**
   Strip all Star-only constructs, yielding **pure Symp Plus**.
*/

// plus program

PlusModuleTree: {
    item: PlusModule,
    children: Map<String, PlusModuleTree>
}

PlusModule: Map<String, PlusDecl>

PlusDecl: {
    kind: "PARAMS"
} | {
    kind: "FUNCTION",
    params: PlusList,
    result: PlusTerm
}

// plus expression

PlusTerm: PlusAtom | PlusList

PlusAtom: Identifier | Literal | Parameter

PlusList: {
    head: Identifier,
    tail: PlusTerm[]
}

// star program

StarModuleTree: {
    item: StarModule,
    children: Map<String, StarModuleTree>
}

StarModule: Map<String, StarDecl>

StarDecl: {
    kind: "PARAMS",
    params: StarList,
    interface: Interface
} | {
    kind: "FUNCTION",
    params: StarList,
    result: StarTerm,
    interface: Interface
}

// star expression

StarTerm: StarAtom | StarList | StarGet

StarAtom: Identifier | Literal | Parameter | Variable

StarList: {
    head: Identifier,
    tail: StarTerm[]
}

StarGet: {
    base: StarTerm,
    projection: string[]
}

Identifier: {
    module: String[],
    label: String
}

Literal: String

Parameter: String

Variable: String

// star interface

Interface: Parametric

Parametric: {
    kind: "PARAMETRIC",
    vars: string[],
    body: Entails
} | Entails

Entails: {
    kind: "ENTAILS",
    input: Product,
    output: Product
} | Product

Product: {
    kind: "PRODUCT",
    items: {label: string, value: Union}[]
} | Union

Union: {
    kind: "UNION",
    items: Primary[],
} | Primary

Primary: {
    kind: "LITERAL",
    value: String
} | {
    kind: "PARAMETER",
    label: String
} | {
    kind: "IDENTIFIER",
    module: String[],
    label: String
} | {
    kind: "VARIABLE",
    label: String
}

EnvModuleTree: {
    item: EnvModule,
    children: Map<String, EnvModuleTree>
}

EnvModule: Map<String, Interface>

// compiler

function compileStarToPlus(moduleTree: StarModuleTree): PlusModuleTree
    envModTree = getInterfaceTree(moduleTree)
    validateResults(moduleTree, envModTree)
    
    return eraseAnnotations(moduleTree)

// pass 1

function getInterfaceTree(moduleTree: StarModuleTree): EnvModuleTree
    envModTree = {item: getInterfaces(moduleTree.item), children: []}
    
    for child in moduleTree.children
        envModTree.children[child.key] = getInterfaceTree(child.value)
    
    return envModTree

function getInterfaces(module: StarModule): EnvModule
    envMod = []
    for decl in module
        if module[decl].interface.kind == "PARAMETRIC"
            declItem = module[decl].interface.body
        
        else
            declItem = module[decl].interface

        if module[decl].kind == "FUNCTION"
            if declItem.kind != "ENTAILS"
                throw Error(`Interface error, expected: 'ENTAILS'`)
        
            intf = declItem.input
        
        else if module[decl].kind == "PARAMS"
            intf = declItem
        
        if intf.kind != "PRODUCT"
            throw Error(`Interface error, expected: 'PRODUCT'`)
        
        if module[decl].params.length != intf.items.length
            throw Error(`Params count not matching, expected count: ${intf.items.length}`)
        
        envMod[decl] = module[decl].interface
    
    return envMod

// pass 2

function validateResults(moduleTree: StarModuleTree, envTree: EnvModuleTree): void
    module = moduleTree.item
    for decl in module
        if module[decl].kind == "FUNCTION"
            inferred = computeStructuralInterface(module[decl].params, envTree)
            checkSatisfies(inferred, module[decl].interface.output, [])

    for i = 0..moduleTree.children.length
        validateResults(moduleTree.children[i], envTree.children[i])

function computeStructuralInterface(term: StarTerm, envTree: EnvModuleTree): Interface
    switch term:
    if term is Literal l
        return {kind: "LITERAL", value: "String"}
    
    if term is Parameter p
        return {kind: "PARAMETER", label: p}
    
    if term is Identifier i
        return {kind: "IDENTIFIER", module: i.module, label: i.label}
    
    if term is Variable v
        return {kind: "VARIABLE", label: v}
    
    if term is StarGet(base, projection):
        baseIntf = computeStructuralInterface(base, envTree)
        return inferProjection(baseIntf, projection)
    
    if term is StarList(head, args):
        headIntf = computeStructuralInterface(head, envTree)
        if headIntf.kind != "IDENTIFIER"
            throw Error(`Head does not resolve to identifier`)
        
        [ok, env] = getEnv(envTree, headIntf)
        if not ok
            throw Error(`Alias not found`)

        if not headIntf.label in env
            throw Error(`Unknown identifier`)

        tmpIntf = env[headIntf.label]
        argIntfs = args.map(arg => computeStructuralInterface(arg, envTree))
        vars = []
        if tmpIntf.kind == "PARAMETRIC"
            tmpIntf.vars.map(var => {vars[var] = null})
            tmpIntf = tmpIntf.body
            
        if tmpIntf.kind == "PRODUCT"
            return checkParams(tmpIntf, argIntfs, vars)
        
        if tmpIntf.kind == "ENTAILS"
            params = tmpIntf.input.items.map(item => item.label)
            return applyEntails(tmpIntf, params, argIntfs, vars)
    
    throw Error(`Interface mismatch`)
    
function getEnv(tree: EnvModuleTree, expr: Identifier): [Boolean, EnvModule]
    module = tree
    for mod in expr.module
        if not mod in module.children
            return [false, null]
        
        module = module.children[mod]
    
    return [true, module.item]

function checkParams(paramsIntf: Interface, args: Interface[], vars: Primary[]): Interface
    if paramsIntf.items.length != args.length
        throw Error(`Arity mismatch`)
    
    for i in 0..args.length
        checkSatisfies(args[i], paramsIntf.items[i].value, vars)

    return paramsIntf
        
function applyEntails(funcIntf: Interface, params: String[], args: Interface[], vars: Primary[]): Interface
    input = funcIntf.input
    output = funcIntf.output
    if input.items.length != args.length
        throw Error(`Arity mismatch`)
    
    for i in 0..args.length
        checkSatisfies(args[i], input.items[i].value, vars)
    
    return substituteParams(output, params, args, vars)

function checkSatisfies(actual: Interface, required: Interface, vars: Primary[]): void
    if required.kind == "LITERAL"
        if actual.kind != "LITERAL"
            throw Error(`Literal mismatch`)

        if actual.value == required.value
            return
        
        throw Error(`Atom mismatch`)

    if required.kind == "PARAMETER"
        if actual.kind != "PARAMETER"
            throw Error(`Parameter mismatch`)

        if actual.label == required.label
            return
        
        throw Error(`Atom mismatch`)

    if required.kind == "IDENTIFIER"
        if actual.kind != "IDENTIFIER"
            throw Error(`Identifier mismatch`)

        if actual.module == required.module and actual.label == required.label
            return
        
        throw Error(`Atom mismatch`)

    if required.kind == "VARIABLE"
        if vars[required.label] == null
            vars[required.label] = actual
            return
        
        else
            checkSatisfies(actual, vars[required.label], vars)
            return

    if required.kind == "UNION"
        if actual.kind == "UNION"
            // exact mode
            throw Error(`Cast required`)
        
        else
            for alt in required.items
                try {
                    checkSatisfies(actual, alt, clone(vars))
                    return
                }
            
            throw Error(`No UNION alternative satisfied`)

    if required.kind == "PRODUCT"
        if actual.kind != "PRODUCT"
            throw Error(`Expected 'PRODUCT'`)
        
        if actual.items.length != required.items.length
            throw Error(`'PRODUCT' arity mismatch`)

        for i in 0..actual.items.length
            checkSatisfies(actual.items[i].value, required.items[i].value, vars)

    if required.kind == "ENTAILS"
        throw Error(`Cannot directly satisfy 'ENTAILS' without application`)

function inferProjection(base: Interface, path: string[]): Interface
    if base.kind == "UNION"
        throw Error(`Cast required`)

    current = base
    for p in path:
        if current.kind != "PRODUCT"
            throw Error(`Cannot project '${p}' from non-product`)

        entry = current.items.find(item => item.label == p)
        if entry == null
            throw Error(`Missing projection: ${p}`)

        current = entry.value

    return current

function substituteParams(output: Interface, params: String[], args: Interface[], vars: Primary[]): Interface
    env = []
    for i in 0..params.length
        env[params[i]] = args[i]

    return substitute(output, env, vars)

function substitute(expr: Interface, env: SubstEnv, vars: Primary[]): Interface
    if expr.kind == "LITERAL"
        return expr
        
    if expr.kind == "PARAMETER"
        if expr.label in env
            return env[expr.label]
        
        else
            return expr
    
    if expr.kind == "IDENTIFIER"
        return expr
    
    if expr.kind == "VARIABLE"
        if vars[expr.label] == null
            throw Error(`Unbound parametric variable`)
        
        return substitute(vars[expr.label], env, vars)

    if expr.kind == "UNION"
        return {
            kind: "UNION",
            items: expr.items.map(item => substitute(item, env, clone(vars)))
        }

    if expr.kind == "PRODUCT"
        return {
            kind: "PRODUCT",
            items: expr.items.map(item => {label: item.label, value: substitute(item.value, env, vars)})
        }
    
    // ENTAILS never shows up

// pass 3

function eraseAnnotations(moduleTree: StarModuleTree): PlusModuleTree
    modTree = {
        item: moduleTree.item.map(decl => eraseIntf(decl)),
        children: []
    }
    
    for child in moduleTree.children
        modTree.children[child.key] = eraseAnnotations(child.value)
    
    return modTree

function eraseIntf(decl: StarDecl): PlusDecl
    if decl.kind == "PARAMS"
        return {kind: "PARAMS", params: decl.params}

    return {
        kind: "FUNCTION"
        params: decl.params,
        result: decl.result
    }

