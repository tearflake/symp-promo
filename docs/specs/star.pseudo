/*
## 1. High-level architecture

The Symp Star framework is best seen as **three passes**:

1. **extract interfaces**
   Build pairs param -> interface.
2. **validate terms**
   Walk expressions and ensure every `GET`, application, and composition is admissible.
3. **Erasure / projection**
   Strip all Star-only constructs, yielding **pure Symp Plus**.
*/

// plus program

PlusModuleTree: {
    item: PlusModule,
    children: PlusModuleTree[]
}

PlusModule: PlusDecl[]

PlusDecl: {
    kind: "PARAMS"
} | {
    kind: "FUNCTION",
    params: PlusList,
    result: PlusTerm
}

// plus expression

PlusTerm: PlusAtom | PlusList

PlusAtom: Identifier | Literal | Parameter

PlusList: {
    head: Identifier,
    tail: PlusTerm[]
}

// star program

StarModuleTree: {
    item: StarModule,
    children: StarModuleTree[]
}

StarModule: StarDecl[]

StarDecl: {
    kind: "PARAMS",
    params: StarList,
    interface: Interface
} | {
    kind: "FUNCTION",
    params: StarList,
    result: StarTerm,
    interface: Interface
}

// star expression

StarTerm: StarAtom | StarList | StarGet

StarAtom: Identifier | Literal | Parameter

StarList: {
    head: Identifier,
    tail: StarTerm[]
}

StarGet: {
    base: StarTerm,
    projection: string[]
}

// shared expressions

Identifier: {
    module: String[],
    label: String
}

Literal: String

Parameter: String

// star interface

Interface: Parametric

Parametric: {
    kind: "PARAMETRIC",
    vars: String[],
    body: Entails
} | Entails

Entails: {
    kind: "ENTAILS",
    input: Product,
    output: Product
} | Product

Product: {
    kind: "PRODUCT",
    items: {label: string, value: Union}[]
} | Union

Union: {
    kind: "UNION",
    items: Primary[],
} | Primary

Primary: {
    kind: "LITERAL",
    value: String
} | {
    kind: "PARAMETER",
    label: String
} | {
    kind: "IDENTIFIER",
    module: String[],
    label: String
} | {
    kind: "VARIABLE",   //pattern matching capture
    label: String
}

EnvModuleTree: {
    item: EnvModule,
    children: EnvModuleTree[]
}

EnvModule: Interface[]

// compiler

function compileStarToPlus(moduleTree: StarModuleTree): PlusModuleTree
    envModTree = getInterfaceTree(moduleTree)
    validateResults(moduleTree, envModTree)
    
    return eraseAnnotationsTree(moduleTree)

// pass 1

function getInterfaceTree(moduleTree: StarModuleTree): EnvModuleTree
    envModTree = {item: getInterfaces(moduleTree.item), children: []}
    for child in moduleTree.children
        envModTree.children[child] = getInterfaceTree(moduleTree.children[child])
    
    return envModTree

function getInterfaces(module: StarModule): EnvModule
    envMod = []
    for decl in module
        envMod[decl] = module[decl].interface
    
    return envMod

// pass 2

function validateResults(moduleTree: StarModuleTree, envTree: EnvModuleTree): void
    module = moduleTree.item
    for decl in module
        validateTopInterfaceWellFormed(module[decl])
        processTerms(module[decl], envTree)

    for i = 0..moduleTree.children.length
        validateResults(moduleTree.children[i], envTree.children[i])

function validateTopInterfaceWellFormed(declItem: StarDecl): void
    interface = declItem.interface
    if declItem.kind == "FUNCTION"
        if interface.kind == "PARAMETRIC"
            vars = interface.vars
            interface = interface.body
        
        if interface.kind != "ENTAILS"
            throw Error(`Interface error, expected: 'ENTAILS'`)
        
    if interface.kind != "PRODUCT"
        throw Error(`Interface error, expected: 'PRODUCT'`)
    
    return

function processTerms(term: StarTerm, envTree: EnvModuleTree): Interface
    switch term:
    if term is Literal l
        return {kind: "LITERAL", value: "String"}
    
    if term is Parameter p
        return {kind: "PARAMETER", label: p}
    
    if term is Identifier i
        return {kind: "IDENTIFIER", module: i.module, label: i.label}
    
    if term is StarGet(base, projection):
        baseIntf = processTerms(base, envTree)
        return inferProjection(baseIntf, projection)
    
    if term is StarList(head, args):
        headIntf = processTerms(head, envTree)
        if headIntf.kind != "IDENTIFIER"
            throw Error(`Head does not resolve to identifier`)
        
        [ok, env] = getEnv(envTree, headIntf)
        if not ok
            throw Error(`Alias not found`)

        if not headIntf.label in env
            throw Error(`Unknown identifier`)

        interface = env[headIntf.label]
        argIntfs = args.map(arg => processTerms(arg, envTree))
        vars = []
        if interface.kind == "PARAMETRIC"
            vars = interface.vars
            interface = interface.body
        
        if interface.kind == "PRODUCT"
            if interface.items.length != args.length
                throw Error(`Arity mismatch`)
            
            env = checkArgs(argIntfs, input, vars): Interface[]

            return [kind: "PRODUCT", items: interface.items]
        
        if interface.kind == "ENTAILS"
            if interface.input.items.length != args.length
                throw Error(`Arity mismatch`)
            
            params = interface.input.items.map(item => item.label)
            input = interface.input
            output = interface.output
            env = checkArgs(argIntfs, input, vars): Interface[]
            inferred = substituteParams(output, params, argIntfs, env)
            checkSatisfies(inferred, output, [], [], [])
            
            return inferred

    throw Error(`Interface mismatch`)

function checkArgs(argIntfs, input, vars): Interface[]
    env = []
    for i in 0..argIntfs.length
        env = checkSatisfies(argIntfs[i], input.items[i].value, env, vars, [])
    
    return env

function getEnv(tree: EnvModuleTree, expr: Identifier): [Boolean, EnvModule]
    module = tree
    for mod in expr.module
        if not mod in module.children
            return [false, null]
        
        module = module.children[mod]
    
    return [true, module.item]

function checkSatisfies(actual: Interface, required: Interface, env: Interface[], vars: String[], occurVars: String[]): Interface[]
    if required.kind == "LITERAL"
        if actual.kind != "LITERAL"
            throw Error(`Literal mismatch`)

        if actual.value == required.value
            return env
        
        throw Error(`Atom mismatch`)

    if required.kind == "PARAMETER"
        if actual.label == required.label
            return env
        
        throw Error(`Parameter mismatch`)

    if required.kind == "IDENTIFIER"
        if actual.kind != "IDENTIFIER"
            throw Error(`Identifier mismatch`)

        if actual.module == required.module and actual.label == required.label
            return env
        
        throw Error(`Identifier mismatch`)

    if required.kind == "VARIABLE"
        if vars[required.label] not exists
            throw Error(`Undeclared variable`)

        if required.label in occurVars
            throw Error(`Cyclic parametric variable detected: ${required.label}`)
                
        if env[required.label] is undefined
            env = clone(env)
            env[required.label] = actual
            return env

        else
            return checkSatisfies(actual, env[required.label], env, vars, [...occurVars, required.label])

    if required.kind == "UNION"
        if actual.kind == "UNION"
            throw Error(`Cast required`)
        
        else
            success = []
            for alt in required.items
                try {
                    env2 = checkSatisfies(actual, alt, env, vars, occurVars)
                    success.push(env2)
                }
            
            if success.length == 0
                throw Error("No UNION alternative satisfied")

            if success.length > 1
                throw Error("Ambiguous UNION match")

            return success[0]

    if required.kind == "PRODUCT"
        if actual.kind != "PRODUCT"
            throw Error(`Expected 'PRODUCT'`)
        
        if actual.items.length != required.items.length
            throw Error(`'PRODUCT' arity mismatch`)

        env2 = env
        for i in 0..actual.items.length
            env2 = checkSatisfies(actual.items[i].value, required.items[i].value, env2, vars, occurVars)

        return env2

    if actual.kind == "ENTAILS" or required.kind == "ENTAILS"
        throw Error(`'ENTAILS' not allowed here`)

    return env
    
function inferProjection(base: Interface, path: string[]): Interface
    if base.kind == "UNION"
        throw Error(`Cast required`)

    current = base
    for p in path:
        if current.kind != "PRODUCT"
            throw Error(`Cannot project '${p}' from non-product`)

        entry = current.items.find(item => item.label == p)
        if entry == null
            throw Error(`Missing projection: ${p}`)

        current = entry.value

    return current

function substituteParams(output: Interface, params: String[], args: Interface[], envVars: Interface[]): Interface
    env = []
    for i in 0..params.length
        env[params[i]] = args[i]

    return substitute(output, env, envVars)

function substitute(expr: Interface, env: SubstEnv, envVars: Interface[], occurVars: String[]): Interface
    if expr.kind == "LITERAL"
        return expr
        
    if expr.kind == "PARAMETER"
        if expr.label in env
            return env[expr.label]
        
        else
            return expr
    
    if expr.kind == "IDENTIFIER"
        return expr
    
    if expr.kind == "VARIABLE"
        if envVars[expr.label] not exists
            throw Error(`Unbound parametric variable: ${expr.label}`)
        
        if occurVars not defined
            occurVars = []
        
        if expr.label in occurVars
            throw Error(`Cyclic parametric variable detected: ${expr.label}`)
                
        return substitute(envVars[expr.label], env, envVars, [...occurVars, expr.label])

    if expr.kind == "UNION"
        return {
            kind: "UNION",
            items: expr.items.map(item => substitute(item, env, envVars, occurVars))
        }

    if expr.kind == "PRODUCT"
        return {
            kind: "PRODUCT",
            items: expr.items.map(item => {label: item.label, value: substitute(item.value, env, envVars, occurVars)})
        }
    
    if expr.kind == "ENTAILS"
        throw Error(`'ENTAILS' not allowed here`)

// pass 3

function eraseAnnotationsTree(moduleTree: StarModuleTree): PlusModuleTree
    modTree = {
        item: getAnnotations(moduleTree.item),
        children: []
    }
    
    for child in moduleTree.children
        modTree.children[child] = eraseAnnotationsTree(moduleTree.children[child])
    
    return modTree

function getAnnotations(module: StarModule): PlusModule
    envMod = []
    for decl in module
        envMod[decl] = eraseIntf(module[decl])
    
    return envMod

function eraseIntf(decl: StarDecl): PlusDecl
    if decl.kind == "PARAMS"
        return {kind: "PARAMS", params: decl.params}

    return {kind: "FUNCTION", params: decl.params, result: decl.result}

